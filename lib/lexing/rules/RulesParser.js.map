{"version":3,"file":"RulesParser.js","sourceRoot":"","sources":["../../../src/lexing/rules/RulesParser.ts"],"names":[],"mappings":"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","sourcesContent":["import Terminal from \"./util/Terminal\";\nconst fs = require('fs');\n\nimport { assert } from '../../util';\nimport Tag from '../util/Tag';\nimport Rule from \"./util/Rule\";\nimport NonTerminal from \"./util/NonTerminal\";\n\n\nexport default class RulesParser {\n\n\t// Parse provided grammar and return it's rules\n\tpublic static getRules(fileName) {\n\t\tlet fileContents = fs.readFileSync(fileName, 'utf8');\n\n\t\treturn fileContents\n\t\t\t// Split rules\n\t\t\t.split(';')\n\n\t\t\t// Remove spaces\n\t\t\t.map(ruleString => ruleString.trim())\n\n\t\t\t.filter(ruleString => !!ruleString)\n\n\t\t\t// Split multirules\n\t\t\t.map(ruleString => {\n\t\t\t\tlet parts = ruleString.split('->');\n\n\t\t\t\tlet lhs = parts[0];\n\t\t\t\tlet rhs = parts[1];\n\n\t\t\t\treturn rhs.split('|').map(rhsPart => lhs + '->' + rhsPart);\n\t\t\t})\n\n\t\t\t// Reduce to single array\n\t\t\t.reduce((acc, curr) => {\n\t\t\t\treturn acc.concat(curr);\n\t\t\t}, [])\n\n\t\t\t// Parse rule string\n\t\t\t.map(ruleString => {\n\t\t\t\tlet parts = ruleString.split('->');\n\n\t\t\t\tlet lhs = parts[0].trim();\n\t\t\t\tlet rhs = parts[1].trim();\n\n\t\t\t\tlet rhsElements = rhs.split(' ')\n\t\t\t\t\t.filter(element => !! element)\n\t\t\t\t\t.map(element => {\n\t\t\t\t\t\tif (/<.*>/.test(element)) {\n\t\t\t\t\t\t\tlet tag = Tag[element.slice(1, -1)];\n\t\t\t\t\t\t\treturn new Terminal(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn new NonTerminal(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\treturn new Rule(\n\t\t\t\t\tnew NonTerminal(lhs),\n\t\t\t\t\trhsElements\n\t\t\t\t);\n\t\t\t});\n\t}\n\n\t// Return all grammar symbols, mentioned in rules, defined by provided grammar\n\tpublic static getGrammarSymbols(rules: Rule[]) {\n\t\tlet result: Array<Terminal|NonTerminal> = [];\n\n\t\trules.forEach(rule => {\n\t\t\tlet ruleSymbols: Array<Terminal|NonTerminal> = [rule.lhs];\n\n\t\t\trule.rhs.forEach(symbol => {ruleSymbols.push(symbol)});\n\n\t\t\truleSymbols.forEach(symbol => {\n\n\t\t\t\tlet found = result.filter(savedSymbol => {\n\t\t\t\t\treturn savedSymbol.equals(symbol);\n\t\t\t\t}).length > 0;\n\n\t\t\t\tif (!found) {\n\t\t\t\t\tresult.push(symbol);\n\t\t\t\t}\n\t\t\t})\n\n\t\t});\n\n\t\treturn result;\n\t}\n}"]}